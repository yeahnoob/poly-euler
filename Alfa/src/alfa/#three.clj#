(ns alfa.three
	(:require
		[clojure.set :refer [union difference intersection subset?]]
		[clojure.core.reducers :as r]
		[clojure.string :refer [split-lines]]
		[alfa.common :refer :all]))

(comment
	(cb/defclient cdb {:bucket "primes"
										 :uris   ["http://127.0.0.1:8091/pools"]}))


(def cm (set! *unchecked-math* true))

(defn sum-sieve
	[^long lim]
	(let [refs (boolean-array (+ 1 lim) true)
				llim (int (Math/sqrt lim))]
		(loop [i (int 3) res (int 2)]
			(if (> i lim)
				res
				(if (aget refs i)
					(if (<= i llim)
						(do (loop [j (int (* i i))]
									(if (> j lim)
										nil
										(recur (do (aset refs j false)
															 (+ j (* i 2))))))
								(recur (+ i 2) (+ res i)))
						(recur (+ i 2) (+ res i)))
					(recur (+ i 2) res))))))

(comment
	(defn put-primes
		[^long lim]
		(let [refs (boolean-array (+ 1 lim) true)
					llim (int (Math/sqrt lim))]
			(loop [i (int 3)]
				(if (> i lim)
					nil
					(if (aget refs i)
						(if (<= i llim)
							(do (loop [j (int (* i i))]
										(if (> j lim)
											nil
											(recur (do (aset refs j false)
																 (+ j (* i 2))))))
									(recur (+ i 2)))
							(recur (do (set-json cdb (keyword (str "prime" i))
																	 {:number i})
												 (+ i 2))))
						(recur (+ i 2))))))))

(defn udivisors
	[n]
	(loop [i 2 res [1 n]]
		(if (> (* i i) n)
			(sort res)
			(recur (+ i 1)
						 (let [num (rem n i)]
							 (if (== 0 num)
								 (let [jum (quot n i)]
									 (if (== 1 (gcd jum i))
										 (conj res i jum)
										 res))
								 res))))))

(defn factmod
	[n modi]
	(loop [i 1 res 1]
		(if (> i n)
			res
			(recur (+ 1 i)
						 (rem (* i res) modi)))))

(defn logbase
	[base num]
	(/ (Math/log num)
		 (Math/log base)))

(defn ^long sol
  [^long nolim ^long lim ^long modi ^long target]
  (let [refs (boolean-array (+ 1 lim) true)
        divs (long-array (+ 1 lim) 0)
        llim (int (Math/sqrt lim))]
    (do (let [j2 (->> (range 1 (+ 1 (Math/floor (logbase 2 lim))))
                      (map #(quot lim (expt 2 %)))
                      (reduce +)
                      (+ 1))]
          (aset divs 2 j2))
        (loop [i (int 3) res (int 1)]
          (if (> i lim)
            res
            (if (aget refs i)
              (do (let [j2 (->> (range 1 (+ 1 (Math/floor (logbase i lim))))
                                (map #(quot lim (expt i %)))
                                (reduce +)
                                (+ 1))]
                    (aset divs i j2))
                  (if (<= i llim)
                    (do (loop [j (* i i)]
                          (if (> j lim)
                            nil
                            (do (aset refs j false)
                                (recur (+ j (* i 2))))))
                        (recur (+ i 2) (+ 1 res)))
                    (recur (+ i 2) (+ res 1))))
              (recur (+ i 2) res))))
        (let [start (->> (range 2 (+ 1 nolim))
                         (filter #(aget refs %))
                         (map #(logbase 2 (aget divs %)))
                         (reduce +))]
          (loop [i (int nolim) res start]
            (if (>= res target)
              (factmod i modi)
              (let [nexi (loop [j (+ i 2)]
                           (if (aget refs j) j (recur (+ j 2))))]
                (recur nexi (+ res (logbase 2 (aget divs nexi)))))))))))

(defn repeating
	[^long n]
	(loop [i (expt 10 (Math/ceil (Math/log10 n)))
				 res #{} tmp [] ires #{}]
		(let [num (quot i n)
					numi (rem i n)]
			(if (some #{numi} res)
				(if (some #{numi} ires)
					[n (count tmp)]
					(recur (* numi 10) res (conj tmp num) (conj ires numi)))
				(recur (* numi 10) (conj res numi) tmp ires)))))

(defn ^long tots
	[^long lim]
	(->> (range 1 lim)
			 (pmap repeating)
			 (max-by second)))

(defn sol500
	[^long start ^long lim ^long target ^long modi]
	(let [primes (sieve lim)
				refs (boolean-array (+ 1 lim) false)
				cdivs (fn [^long n ^long maxi]
								(->> (range 1 (+ 1 (Math/floor (logbase n maxi))))
										 (map #(quot maxi (expt n %)))
										 (reduce +)
										 (+ 1)))]
		(do (doseq [i primes]
					(aset refs i true))
				(loop [i (int start)]
					(let [num (loop [j 2 res 0]
											(if (> j i)
												res
												(if (aget refs j)
													(recur (+ j 1)
																 (+ res (logbase 2 (cdivs j i))))
													(recur (+ j 1)
																 res))))]
						(if (>= num target)
							(factmod i modi)
							(recur (+ i 1))))))))

;; extract variable -> a very cool thing to use

(defn sol
	[^long start ^long tar]
	(let [psqr? (fn [^long n]
								(if (== 1 n)
									false
									(let [num (StrictMath/sqrt n)]
										(== (long num) num))))
				sat? (fn [n]
							 (let [num (- (long (StrictMath/cbrt n)) 1)]
								 (loop [i num res (int 0)]
									 (if (< i 4)
										 (if (== 4 res) true false)
										 (let [ncube (expt i 3)]
											 (recur (- i 1)
															(if (psqr? (- n ncube)) (+ 1 res) res)))))))]
		(loop [i (long start) res []]
			(if (>= (count res) tar)
				(reduce + res)
				(let [numi (numcol i)
							rev (reverse numi)
							n2 (colnum (concat numi rev))
							n1 (colnum (concat (butlast numi) rev))]
					(if (sat? n1)
						(if (sat? n2)
							(recur (+ 1 i) (conj res n1 n2))
							(recur (+ i 1) (conj res n1)))
						(if (sat? n2)
							(recur (+ 1 i) (conj res n2))
							(recur (+ 1 i) res))))))))

(defn solp
	[^long start ^long tar]
	(let [psqr? (fn [^long n]
								(if (== 1 n)
									false
									(let [num (StrictMath/sqrt n)]
										(== (long num) num))))
				sat? (fn [n]
							 (let [num (- (long (StrictMath/cbrt n)) 1)]
								 (loop [i num res (int 0)]
									 (if (< i 4)
										 (if (== 4 res) true false)
										 (let [ncube (expt i 3)]
											 (recur (- i 1)
															(if (psqr? (- n ncube)) (+ 1 res) res)))))))]
		(->> (iterate inc start)
				 (r/mapcat #(let [numi (numcol %)
													rev (reverse numi)
													n2 (colnum (concat numi rev))
													n1 (colnum (concat (butlast numi) rev))]
										 (if (sat? n1)
											 (if (sat? n2) (vector n1 n2) (vector n1))
											 (if (sat? n2) (vector n2) nil))))
				 (r/take tar)
				 (r/fold +))))

(defn solb
	[^long lim-sqr ^long lim-cube]
	(let [palin? (fn [^long n]
								 (let [ncol (numcol n)]
									 (= ncol (reverse ncol))))]
		(->> (+ isqr jcube)
				 (for [i (range 2 (+ lim-sqr 1))
							 j (range 2 (+ lim-cube 1))
							 :let [isqr (* i i)
										 jcube (* j j j)]
							 :when (palin? (+ isqr jcube))])
				 distinct sort
				 (take 5))))
























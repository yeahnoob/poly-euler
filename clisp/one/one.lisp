(defun div (a b)
  (declare (optimize (speed 3)) (fixnum a b))
  (truncate (/ a b)))

(defun find-cycle (n)
  "Find the number of recurring digits in 1/n"
  (declare (optimize (speed 3))
	   (fixnum n))
  (let ((refs (make-array n :initial-element nil))
	(refs2 (make-array n :initial-element nil)))
    (labels ((outer (i res res2)
	       (declare (optimize (speed 3))
			(fixnum i res res2))
	       (if (aref refs2 i)
		   res2
		   (let ((rems (rem (* 10 i) n)))
		     (if (= 0 rems)
			 0
			 (if (aref refs i)
			     (progn (setf (aref refs2 i) t)
				    (outer rems res (+ 1 res2)))
			     (progn (setf (aref refs i) t)
				    (outer rems (+ 1 res) res2))))))))
      (outer 1 0 0))))

(defun max-cycle (lim)
  "Returns the n in the range 2-lim of which recurring digits achieve maximum"
  (declare (optimize (speed 3))
	   (fixnum lim))
  (labels ((helper (i n res)
	     (declare (optimize (speed 3))
		      (fixnum i n res))
	     (if (> res i)
		 (list n res)
		 (let ((tmp (find-cycle i)))
		   (if (> tmp res)
		       (helper (- i 1) i tmp)
		       (helper (- i 1) n res))))))
    (helper lim lim 0)))

(defun euler28 (lim)
  (declare (optimize (speed 3)) (fixnum lim))
  (labels ((looper (a b res i)
	      (declare (fixnum a b res i))
	      (if (= i lim)
		  res
		  (let ((tempa (+ a (+ 8 (- a b)))))
		    (looper tempa a (+ res (* 4 tempa)) (+ 2 i))))))
    (looper 6 1 25 3)))

(defun prime? (p)
  (declare (optimize (speed 3)) (fixnum p))
  (if (< p 2)
      nil
      (if (= 2 p)
	  t
	  (if (evenp p)
	      nil
	      (let ((lim (isqrt p)))
		(labels ((helper (i)
			   (declare (optimize (speed 3)) (fixnum i))
			   (if (> i lim)
			       t
			       (if (= 0 (rem p i))
				   nil
				   (helper (+ i 2))))))
		  (helper 3)))))))

(defun next-prime (p)
  (declare (optimize (speed 3)) (fixnum p))
  (cond ((= p 2) 3)
	((prime? (+ p 2)) (+ p 2))
	(:otherwise (next-prime (+ p 2)))))

(defun prev-prime (p)
  (declare (optimize (speed 3)) (fixnum p))
  (cond ((<= p 2) nil)
	((= p 3) 2)
	((prime? (- p 2)) (- p 2))
	(:otherwise (prev-prime (- p 2)))))

(defun euler27 (lim)
  (declare (optimize (speed 3)) (fixnum lim))
  (labels ((blooper (b resb)
	     (declare (fixnum b))
	     (labels ((alooper (a cura resa)
			(declare (fixnum a cura resa))
			(labels ((nlooper (n resn)
				   (declare (fixnum n resn))
				   (if (prime? (+ (* n n) (* a n) b))
				       (nlooper (+ 1 n) (+ 1 resn))
				       resn)))
			  (cond
			    ((> a lim)
			     (list resa cura b))
			    ((<= (+ a b 1) 0)
			     (alooper (+ 1 a) cura resa))
			    (:otherwise
			     (let ((resn (nlooper 1 1)))
			       (if (> resn resa)
				   (alooper (+ 2 a) a resn)
				   (alooper (+ 2 a) cura resa))))))))
	       (if (< b (first resb))
		   (* (second resb) (third resb))
		   (let ((tmpres (alooper (- lim) (- lim) 1)))
		     (if (> (first tmpres) (first resb))
			 (blooper (prev-prime b) tmpres)
			 (blooper (prev-prime b) resb)))))))
    (blooper 997 (list 0 0 0))))

(defun euler27b (lim)
  (declare (optimize (speed 3)) (fixnum lim))
  (labels ((blooper (b resb)
	     (declare (fixnum b))
	     (labels ((alooper (a cura resa)
			(declare (fixnum a cura resa))
			(labels ((nlooper (n resn)
				   (declare (fixnum n resn))
				   (if (prime? (+ (* n n) (* a n) b))
				       (nlooper (+ 1 n) (+ 1 resn))
				       resn)))
			  (cond
			    ((< a (- lim))
			     (list resa cura b))
			    ((<= (+ a b 1) 0)
			     (alooper (- a 2) cura resa))
			    (:otherwise
			     (let ((resn (nlooper 1 1)))
			       (if (> resn resa)
				   (alooper (- a 2) a resn)
				   (alooper (- a 2) cura resa))))))))
	       (if (< b (first resb))
		   (* (second resb) (third resb))
		   (let ((tmpres (alooper lim lim 1)))
		     (if (> (first tmpres) (first resb))
			 (blooper (prev-prime b) tmpres)
			 (blooper (prev-prime b) resb)))))))
    (blooper 997 (list 0 0 0))))

(defun sieves (lim)
  (declare (optimize (speed 3)) (fixnum lim))
  (let ((llim (isqrt lim))
	(refs (make-array lim :initial-element t)))
    (labels ((outer (i res)
	       (declare (optimize (speed 3))
			(fixnum i)
			(dynamic-extent res))
	       (labels ((inner (p)
			  (declare (optimize (speed 3))
				   (fixnum p))
			  (if (< p lim)
			      (progn (setf (aref refs p) nil)
				     (inner (+ p (* 2 i))))
			      (+ 2 i))))
		 (if (< i lim)
		     (if (and (<= i llim) (aref refs i))
			 (progn (inner (* i i))
				(outer (+ i 2)
				       (cons i res)))
			 (outer (+ i 2)
				(if (aref refs i)
				    (cons i res)
				    res)))
		     (reverse res)))))
      (outer 3 (list 2)))))

(defun euler27a (lim)
  (declare (optimize (speed 3)) (fixnum lim))
  (reduce '*
	  (rest
	   (first
	    (sort (loop for b in (sieves lim)
		     collect
		       (labels
			   ((outer (a cura res)
			      (declare (fixnum cura res))
			      (if (null a)
				  (list res cura b)
				  (labels ((inner (n resa)
					     (declare (fixnum n resa))
					     (if (prime? (+ (* n n)
							    (* (first a) n)
							    b))
						 (inner (+ 1 n) (+ 1 resa))
						 resa)))
				    (let ((resn (inner 1 1)))
				      (if (> resn res)
					  (outer (rest a) (first a) resn)
					  (outer (rest a) cura res)))))))
			 (outer (remove-if-not
				 #'(lambda (x) (> (+ 1 x b) 0))
				 (loop for m from (- lim) to lim collect m))
				(- lim)
				1)))
		  '> :key 'first)))))

(defun numcol (n)
  (declare (optimize (speed 3))
	   (fixnum n))
  (labels ((looper (i res)
	      (declare (fixnum i))
	      (if (< i 10)
		  (cons i res)
		  (looper (div i 10)
		     (cons  (rem i 10) res )))))
    (looper n nil)))

(defun sum-pow5a (n)
  (declare (optimize (speed 3))
	   (fixnum n))
  (labels ((looper (i res)
	      (declare (fixnum i res))
	      (if (< i 10)
		  (+ res (expt i 5))
		  (looper (truncate (/ i 10))
		     (+ res (expt (rem i 10) 5))))))
    (looper n 0)))

(defun sum-fif (n)
  (declare (optimize (speed 3))
	   (fixnum n))
  (reduce '+ (mapcar #'(lambda (x) (expt x 5)) (numcol n))))

(defparameter refs5 (make-array 10
				:initial-contents
				(mapcar #'(lambda (x) (expt x 5))
					(range 0 9 1))))

(defun range (i j k)
  (declare (optimize (speed 3))
	   (fixnum i j k))
  (if (< i j)
      (loop for m from i to j by k collect m)
      (loop for m from i downto j by k collect m)))

(defun sum-pow5 (n)
  (declare (optimize (speed 3))
	   (fixnum n))
  (labels ((looper (i res)
	      (declare (fixnum i res))
	      (if (< i 10)
		  (+ res (aref refs5 i))
		  (looper (div i 10)
		     (+ res (aref refs5 (rem i 10)))))))
    (looper n 0)))

(defun all-sum5 (lim)
  (declare (optimize (speed 3))
	   (fixnum lim))
  (labels ((looper (m res)
	      (declare (fixnum m res))
	      (if (> m lim)
		  res
		  (let ((summ (sum-pow5 m)))
		    (if (= summ m)
			(looper (+ 1 m) (+ res summ))
			(looper (+ 1 m) res))))))
    (looper 10 0)))

(defun sumfif? (n)
  (declare (optimize (speed 3))
	   (fixnum n))
  (labels ((looper (i res)
	      (declare (fixnum i res))
	      (if (< i 10)
		  (= n (+ res (aref refs5 i)))
		  (if (> res n)
		      nil
		      (looper (div i 10)
			 (+ res (aref refs5 (rem i 10))))))))
    (looper n 0)))

(defun euler30 (lim)
  (declare (optimize (speed 3))
	   (fixnum lim))
  (labels ((looper (m res)
	      (declare (fixnum m res))
	      (if (= 10 m)
		  res
		  (if (sumfif? m)
		      (looper (- m 1) (+ m res))
		      (looper (- m 1) res)))))
    (looper lim 0)))

(defun euler30a (lim)
  (declare (optimize (speed 3)))
  (labels ((looper (m res)
	      (declare (fixnum m res))
	      (if (= 10 m)
		  res
		  (let ((summ (sum-pow5 m)))
		    (if (= summ m)
			(looper (- m 1) (+ res summ))
			(looper (- m 1) res))))))
    (looper lim 0)))


(defun take-while (f ls)
  (declare (optimize (speed 3)))
  (if (funcall f (first ls))
      (cons (first ls) (take-while f (rest ls)))
      '()))

(defun iterate (f g i)
  (declare (optimize (speed 3)))
  (if (not (funcall g i))
      '()
      (append (iterate f g (funcall f i))
	      (list i))))

(defparameter cs (make-array 8 :initial-contents '(1 2 5 10 20 50 100 200)))

(defun suma-coins (n)
  (declare (optimize (speed 3))
	   (fixnum n))
  (labels ((sumas (i c)
	     (declare (fixnum i c))
	     (labels ((inner (x res)
			(declare (fixnum x res))
			(if (< i (* x (aref cs c)))
			    res
			    (inner (+ 1 x)
				   (+ res (sumas (- i (* x (aref cs c)))
						 (- c 1)))))))
	       (cond ((= i 0) 1)
		     ((= c 0) 1)
		     (:else (inner 0 0))))))
    (sumas n 7)))




(defun isuma (i c)
  (declare (optimize (speed 3)) (fixnum i c))
  (labels ((inner (x res)
	     (declare (fixnum x res))
	     (if (< i (* x c))
		 res
		 (inner (+ 1 x)
			(+ res (isuma (- i (* x c))
				      (- c 1)))))))
    (cond ((= i 0) 1)
	  ((= c 1) 1)
	  (:else (inner 0 0)))))

(defun suma-ints (n)
  (declare (optimize (speed 3))
	   (fixnum n))
  (isuma n (- n 1)))









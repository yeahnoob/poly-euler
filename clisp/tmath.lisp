(defun div (a b)
  (declare (optimize (speed 3)) (fixnum a b))
  (truncate (/ a b)))

(defun prime? (p)
  (declare (optimize (speed 3)) (fixnum p))
  (let ((lim (isqrt p)))
    (declare (fixnum lim))
    (labels ((helper (i)
	       (declare (optimize (speed 3)) (fixnum i))
	       (if (> i lim)
		   t
		   (if (= 0 (rem p i))
		       nil
		       (helper (+ i 2))))))
      (helper 3))))

(defun true-prime? (p)
  (declare (optimize (speed 3)) (fixnum p))
  (if (= 2 p)
      t
      (if (evenp p)
	  nil
	  (let ((lim (isqrt p)))
	    (labels ((helper (i)
		       (declare (optimize (speed 3)) (fixnum i))
		       (if (> i lim)
			   t
			   (if (= 0 (rem p i))
			       nil
			       (helper (+ i 2))))))
	      (helper 3))))))

(defun next-prime (p)
  (declare (optimize (speed 3)) (fixnum p))
  (if (= p 2)
      3
      (labels ((helper (i)
		 (declare (optimize (speed 3)) (fixnum i))
		 (if (prime? i)
		     i
		     (helper (+ i 2)))))
	(helper (+ p 2)))))

(defun pfactors (p)
  (declare (optimize (speed 3)) (fixnum p))
  (labels ((helper (i n lasti res)
	     (declare (optimize (speed 3)) (fixnum i n lasti))
	     (if (prime? n)
		 (if (= n lasti)
		     res
		     (cons n res))
		 (if (zerop (rem n i))
		     (helper 2 (div n i) i (cons i res))
		     (helper (next-prime i) n lasti res)))))
    (helper 2 p 2 nil)))

(defun largest-pfactors (p)
  (declare (optimize (speed 3)) (fixnum p))
  (labels ((helper (i n stat)
	     (declare (optimize (speed 3)) (fixnum i n))
	     (if stat
		 (if (prime? n)
		     n
		     (helper i n nil))
		 (if (zerop (rem n i))
		     (helper 2 (div n i) t)
		     (helper (next-prime i) n nil)))))
    (helper 2 p t)))

(defun sum-primes (lim)
  (declare (optimize (speed 3)) (fixnum lim))
  (labels ((helper (i res)
	     (declare (optimize (speed 3)) (fixnum i res))
	     (if (> i lim)
		 res
		 (if (prime? i)
		     (helper (+ i 2) (+ i res))
		     (helper (+ i 2) res)))))
    (helper 7 10)))

(defparameter limits (expt 10 999))

(defun fibo (lim)
  (declare (optimize (speed 3))
	   (bignum lim))
  (labels ((helper (i j idx)
	     (declare (optimize (speed 3))
		      (fixnum idx))
	     (if (> i lim)
		 idx
		 (helper (+ i j) i (+ 1 idx)))))
    (helper 1 1 1)))

(defun nth-prime (n)
  "Returns the nth terms of positive primes"
  (declare (optimize (speed 3)) (fixnum n))
  (labels ((helper (i idx)
	     (declare (optimize (speed 3))
		      (fixnum i idx))
	     (if (= idx n)
		 i
		 (helper (next-prime i) (+ 1 idx)))))
    (helper 2 1)))

(defun count-factors (n)
  (declare (optimize (speed 3)) (fixnum n))
  (let ((lim (ceiling (sqrt n))))
    (labels ((helper-even (i res)
	       (declare (optimize (speed 3)) (fixnum i res))
	       (if (> i lim)
		   res
		   (if (zerop (rem n i))
		       (let ((divs (div n i)))
			 (if (= i divs)
			     (+ 1 res)
			     (helper-even (+ i 1) (+ 2 res))))
		       (helper-even (+ i 1) res))))
	     (helper-odd (i res)
	       (declare (optimize (speed 3)) (fixnum i res))
	       (if (> i lim)
		   res
		   (if (zerop (rem n i))
		       (let ((divs (div n i)))
			 (if (= i divs)
			     (+ 1 res)
			     (helper-odd (+ i 2) (+ 2 res))))
		       (helper-odd (+ i 2) res)))))
      (if (oddp n)
	  (helper-odd 3 2)
	  (helper-even 2 2)))))

(defun sum-pdivs (n)
  (declare (optimize (speed 3)) (fixnum n))
  (let ((lim (isqrt n)))
    (labels ((helper-even (i res)
	       (declare (optimize (speed 3)) (fixnum i res))
	       (if (> i lim)
		   res
		   (if (zerop (rem n i))
		       (let ((divs (div n i)))
			 (if (= i divs)
			     (+ i res)
			     (helper-even (+ i 1) (+ i divs res))))
		       (helper-even (+ i 1) res))))
	     (helper-odd (i res)
	       (declare (optimize (speed 3)) (fixnum i res))
	       (if (> i lim)
		   res
		   (if (zerop (rem n i))
		       (let ((divs (div n i)))
			 (if (= i divs)
			     (+ i res)
			     (helper-odd (+ i 2) (+ i divs res))))
		       (helper-odd (+ i 2) res)))))
      (if (oddp n)
	  (helper-odd 3 1)
	  (helper-even 2 1)))))
 
(defun sum-amic (lim)
  (declare (optimize (speed 3)) (fixnum lim))
  (labels ((helper (i res)
	     (declare (optimize (speed 3)) (fixnum i res))
	     (if (> i lim)
		 res
		 (let ((amic (sum-pdivs i)))
		   (if (= i amic)
		       (helper (+ 1 i) res)
		       (let ((div-amic (sum-pdivs amic)))
			 (if (= i div-amic)
			     (helper (+ 1 i) (+ i res))
			     (helper (+ 1 i) res))))))))
    (helper 2 0)))

(defun sum-amicables (lim)
  (declare (optimize (speed 3)) (fixnum lim))
  (labels ((helper (i res refs)
	     (declare (optimize (speed 3))
		      (fixnum i res)
		      (dynamic-extent refs))
	     (if (> i lim)
		 res
		 (if (member i refs)
		     (helper (+ 1 i) res refs)
		     (let ((amic (sum-pdivs i)))
		       (if (= i amic)
			   (helper (+ 1 i) res refs)
			   (let ((div-amic (sum-pdivs amic)))
			     (if (= i div-amic)
				 (helper (+ 1 i)
					 (+ amic i res)
					 (cons amic refs))
				 (helper (+ 1 i) res refs)))))))))
    (helper 2 0 nil)))

(defun first-triangle-having-lim-factors (n lim)
  (declare (optimize (speed 3)) (fixnum n lim))
  (let* ((triangle (div (* n (+ 1 n)) 2))
	 (factors (count-factors triangle)))
    (if (>= factors lim)
	(list n triangle)
	(first-triangle-having-lim-factors (+ 1 n) lim))))

(defun collatz (i)
  (declare (optimize (speed 3)) (fixnum i))
  (if (= 1 i)
      1
      (+ 1 (if (evenp i)
	       (collatz (div i 2))
	       (collatz (+ 1 (* 3 i)))))))

(defun max-collatz-under-lim (starting lim)
  (declare (optimize (speed 3)) (fixnum starting lim))
  (labels ((helper (i res lres)
	     (declare (optimize (speed 3))
		      (fixnum i res lres))
	     (if (> i lim)
		 res
		 (let ((colls (collatz i)))
		   (if (> colls lres)
		       (helper (+ 2 i) i colls)
		       (helper (+ 2 i) res lres))))))
    (helper starting 1 1)))

(defun sum-sieves (lim)
  (declare (optimize (speed 3)) (fixnum lim))
  (let ((llim (isqrt lim))
	(refs (make-array lim :initial-element t)))
    (labels ((outer (i res)
	       (declare (optimize (speed 3)) (fixnum i res))
	       (labels ((inner (p)
			  (declare (optimize (speed 3))
				   (fixnum p))
			  (if (< p lim)
			      (progn (setf (aref refs p) nil)
				     (inner (+ p (* 2 i))))
			      (+ 2 i))))
		 (if (< i lim)
		     (if (and (<= i llim) (aref refs i))
		      (progn (inner (* i i))
			     (outer (+ i 2)
				    (+ i res)))
		      (outer (+ i 2)
			     (if (aref refs i)
				 (+ i res)
				 res)))
		     (+ 2 res)))))
      (outer 3 0))))

(defun sieves (lim)
  (declare (optimize (speed 3)) (fixnum lim))
  (let ((llim (isqrt lim))
	(refs (make-array lim :initial-element t)))
    (labels ((outer (i res)
	       (declare (optimize (speed 3))
			(fixnum i)
			(dynamic-extent res))
	       (labels ((inner (p)
			  (declare (optimize (speed 3))
				   (fixnum p))
			  (if (< p lim)
			      (progn (setf (aref refs p) nil)
				     (inner (+ p (* 2 i))))
			      (+ 2 i))))
		 (if (< i lim)
		     (if (and (<= i llim) (aref refs i))
		      (progn (inner (* i i))
			     (outer (+ i 2)
				    (cons i res)))
		      (outer (+ i 2)
			     (if (aref refs i)
				 (cons i res)
				 res)))
		     (reverse res)))))
      (outer 3 (list 2)))))

(defun nth-sieve (m n)
  (declare (optimize (speed 3)) (fixnum m n))
  (let* ((lim (* m n))
	 (llim (isqrt lim))
	 (refs (make-array lim :initial-element t)))
    (labels ((outer (i j res)
	       (declare (optimize (speed 3))
			(fixnum i j res))
	       (labels ((inner (p)
			  (declare (optimize (speed 3))
				   (fixnum p))
			  (if (< p lim)
			      (progn (setf (aref refs p) nil)
				     (inner (+ p (* 2 i))))
			      1)))
		 (if (< j m)
		     (if (and (<= i llim) (aref refs i))
			 (progn (inner (* i i))
				(outer (+ i 2) (+ 1 j) i))
			 (if (aref refs i)
			     (outer (+ 2 i) (+ 1 j) i)
			     (outer (+ i 2) j res)))
		     res))))
      (outer 3 1 2))))

(defun abundants (lim)
  (declare (optimize (speed 3)) (fixnum lim))
  (labels ((helper (i res)
	     (declare (optimize (speed 3))
		      (fixnum i))
	     (if (= i 11)
		 res
		 (if (< i (sum-pdivs i))
		     (helper (- i 1) (cons i res))
		     (helper (- i 1) res)))))
    (helper lim '())))

(defun sum-nonabun-ngaco (lim)
  (declare (optimize (speed 3)) (fixnum lim))
  (let ((abuns (make-array (+ 1 lim) :initial-element nil))
	(sum-abuns (make-array (+ 1 lim) :initial-element nil)))
    (labels ((helper (i)
	       (declare (optimize (speed 3)) (fixnum i))
	       (labels ((ihelper (j)
			  (declare (optimize (speed 3)) (fixnum j))
			  (if (<= (+ i j) lim)
			      (progn (if (aref abuns j)
					 (setf (aref sum-abuns (+ i j)) t))
				     (ihelper (+ 1 j)))
			      1))
			(sum-helper (i res)
			  (declare (optimize (speed 3)) (fixnum i res))
			  (if (< i lim)
			      (if (not (aref sum-abuns i))
				  (sum-helper (+ i 1) (+ i res))
				  (sum-helper (+ i 1) res))
			      res)))
		 (if (<= i (div lim 2))
		     (if (aref abuns i)
			 (progn (ihelper i)
				(helper (+ i 1)))
			 (helper (+ i 1)))
		     (sum-helper 1 0)))))
      (progn (loop for k from 1 to lim
		do (if (< k (sum-pdivs k))
		       (setf (aref abuns k) t)))
	     (helper 1)))))

(defun sum-nonabun (lim)
  (declare (optimize (speed 3)) (fixnum lim))
  (let ((abuns (make-array (+ 1 lim) :initial-element nil))
	(sum-abuns (make-array (+ 1 lim) :initial-element nil)))
    (progn (loop for i from 12 to lim
	      do (if (< i (sum-pdivs i))
		     (setf (aref abuns i) t)))
	   (loop for i from 1 to (div lim 2)
	      do (if (aref abuns i)
		     (loop for j from i
			do (if (aref abuns j)
			       (setf (aref sum-abuns (+ i j)) t))
			until (>= (+ i j) lim))))
	   (loop for i from 1 to lim
	      when (not (aref sum-abuns i))
	      sum i))))

(defun pita (lim)
  (declare (optimize (speed 3)) (fixnum lim))
  (labels ((outer (a)
	     (declare (optimize (speed 3))
		      (fixnum a))
	     (labels ((inner (b)
			(declare (optimize (speed 3))
				 (fixnum b))
			(let ((c (- lim b a)))
			  (if (> b c)
			      nil
			      (if (= (+ (* a a) (* b b))
				     (* c c))
				  (* a b c)
				  (inner (+ 1 b)))))))
	       (let ((res (inner (+ 1 a))))
		 (if res res (outer (+ 1 a)))))))
    (outer 3)))

(defun int? (n)
  (declare (optimize (speed 3)) (float n))
  (= (truncate n) n))

(defun find-repeat (p)
  (declare (optimize (speed 3)) (fixnum p))
  (let ((n (/ 1 p)))
    (labels ((helper (i)
	       (declare (optimize (speed 3)) (fixnum i))
	       (let ((res (* (expt 10 i) n)))
		 (labels ((ihelper (j)
			    (declare (optimize (speed 3)) (fixnum j))
			    (if (= i j)
				nil
				(let ((tmp (* (expt 10 j) n)))
				  (if (integerp (- res tmp))
				      (- i j)
				      (ihelper (+ 1 j)))))))
		   (if (integerp res)
		       0
		       (let ((jmp (ihelper 0)))
			 (if jmp jmp (helper (+ 1 i)))))))))
      (helper 1))))

(defun drop-while (f ls)
  (declare (optimize (speed 3)))
  (if (funcall f (first ls))
      (drop-while f (rest ls))
      ls))

(defun find-max-repeat (start lim)
  (declare (optimize (speed 3)) (fixnum start lim))
  (sort (mapcar #'(lambda (x)  (list x (find-repeat x)))
		(drop-while #'(lambda (x) (< x start))
			    (sieves lim)))
	'> :key 'second))

(defun max-cycle (p)
  (declare (optimize (speed 3)) (fixnum p))
  (labels ((helper (i n res)
	     (declare (optimize (speed 3))
		      (fixnum i n res))
	     (if (= p n)
		 n
		 (let ((tmp (find-repeat i)))
		   (if (> tmp res)
		       (helper (+ 1 i) i tmp)
		       (helper (+ 1 i) n res))))))
    (helper 2 2 0)))

(defparameter cs (make-array 8 :initial-contents '(1 2 5 10 20 50 100 200)))









